# Cplusplus运算符重载

类的运算符重载有三种情况：

* 将运算符重载成**类成员函数**

* 将运算符重载成**友元函数**

* 将运算符重载成**普通函数**


> Cplusplus规定，三目运算符与几类特殊的运算符\`\* ，. ， :: ，sizeof ，? :\`等不能重载



这里给出一个基本的重载规则：

一般情况下: 单目算符重载为成员函数, 双目算符重载为友元. 而且重载其一即可.  
若有 双目算符, 函数内部要修改成员变量啥的, 可以重载为成员函数.

重载成成员函数
---

对于双目运算符也就是说是这样的形式`A 运算符 B`,如果重载成类成员函数，那么重载成成员函数的形式是
> A operator 运算符 (B)
重载成成员函数，因为在成员函数调用中隐藏着一个this，所以函数参数中第一个参数为自身的话就可以省略这个this参数；这里其实可以用一般的思维去理解， 所谓的运算符重载，就是在cplusplus中， 运算符也是被视为函数，那么上面的公式就是对运算符函数调用的形式`A.运算符函数(参数B)`，比如说`A+B`那么翻译出来就是`A.+(B)`这里的＋是函数名;

如果将运算符重载函数作为成员函数，它可以通过this指针自由地访问本类的数据成员，因此可以少写一个函数的参数。但必须要求运算表达式第一个参数(即运算符左侧的操作数)是一个类对象，而且与运算符函数的类型相同。因为必须通过类的对象去调用该类的成员函数，而且只有运算符重载函数返回值与该对象同类型，运算结果才有意义


重载成友元函数
---

重载成友元函数， 那么我们就可以将运算符同样当成一个普通函数去理解就好了，在类声明的中声明运算符友元函数：
> friend 返回值 operator 运算符(参数1，参数2); //参数中通常有一个类对象，不然就没有任何意义了

- 有些运行符不能重载为友元函数，它们是：=,(),[]和-＞。这个其实也很好理解的， 因为这些运算符通常都是需要类对象作为运算符的调用主体，想象一下， 如果没有对象去调用`()， ->`那么该如何理解呢？
```cplusplus
friend ＜类型说明符＞ operator ＜运算符＞(＜参数表＞) {
   ……
}
```

注意⚠️：
---

前置自增自减运算符`++A, --A`的声明形式:
> A& operator++(); A& operator--(); //  

后置自增自减运算符`A++, A--`的声明形式:
> A& operator++(int); A& operator--(int); //  这里的int只是作为编译器的标示，没有实际意义，用来区分前置自增自减运算符

重载流运算符时只能重载成友元函数， 因为流运算符要求第一个参数时流本身， 所以自然而然不能重载成成员函数了， 如果重载成成员函数， 那么`<<` `>>`的左操作数就会是类对象自身
```cplusplus
    istream & operator >> (istream &, 自定义类 &);
    ostream & operator << (ostream &, 自定义类 &);
```


