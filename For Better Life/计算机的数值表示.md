# 计算机数值表示

- 右移 逻辑右移 & 算数右移

c语言中 unsigned 右移都是逻辑右移， 也就意味着， 右移最高有效位【MSB】是补`0`的；C语言标准中并没有指定signed 的右移实现规范， 但是目前所有的编译器都是使用的算数右移，也就是说右移过程中，最高位补的是原数值的而进制表示的最高位；

对于java，标准更为明确，java提供了逻辑右移 `>>>` 和 算术右移 `>>` 两个运算符来避免这样的奇异；


- 数值的类型转化

默认可以由`短`的转换成`长`的;[short to long]; 在C语言中， 转换都是先进行长度转化， 再进行类型转换；
```c
#include "stdio.h"

void show_bits(void* p, const unsigned len) {
  if (0 == len)
    return;
  unsigned i = 0;
  while(i++ < len) {
    printf("%x ", *(unsigned char*)p++);
  }
}

int main() {
  char c = -2;
  unsigned short us = c;
  printf("c:%d \t\t, show in bits:", c);
  show_bits(&c, sizeof(char));
  printf("\n");

  printf("us:%d \t, show in bits:", us);
  show_bits(&us, sizeof(unsigned short));
  printf("\n");
}
```

在我Intel的机器上输出如下：
```shell
c:-2            , show in bits:fe
us:65534        , show in bits:fe ff
```
因为是小端的机器， 所以出来的数据是倒着的， 如果我们**纠正**过来，那么就是`c: 0xfe, us: 0xff fe`； 这个例子可以说明在我们使用赋值的方式扩展C语言数字位的时候，首先是进行了带符号位的长度表示， 要理解这一点， 我们首先要抛开c语言的类型的表示，对于unsigned， signed的数据同一个数据来说， 他们的二进制表示方式其实一直都是那样， 不同的是c语言以不同类型去理解而已，比如说单字节表示方式中的`f9`, 你将它用`char c =  0xf9`表示，那么就是告诉编译器，将它作为有符号的char类型解析， 那么他就是`-7`; 如果通过`uchar c = 0xf9`来解析； 那么他就是`249`； 但是实际上， 内存中， 数据一直就是0xf9; 没有改变过...; 很明显我们可以简单的发现，`249-256 = -7` 这也是设计上一个精妙的地方， 具体详细的信息可以看《深入理解计算机系统》第二章，信息的表示；

回到上面那个问题， 当我们将char类型的变量`c=-2` [内存中fe，占1个字节] 赋值给`unsigned short`类型变量的时候[内存长度两个字节，这里我们先假设0x00 00];如果真像我们自然思考的那样，结果应该是:`0x00fe`,但是实际上却是：`0xfffe`; 所以机器不是我们这样简单的去处理的， 实际上，首先， 机器将0xfe 转化成了 0xfffe，也就是说，他是将有符号单字节类型char`-2  0xfe` 转换成双字节类型short的`-2 0xff fe`，之后再将short转化成了无符号类型的方式表示； 因为我们前面说了，有符号无符号只是c语言中解析的这个内存的方式而已； 那么我们可以推测出，将单字节`0xfe`的内存，转成双字节的内存`0xff fe`; 如果是`0x02` 扩展到双字节内存那么就是`0x00 02`; 也就是说， 她是将内存表示中的符号位来填充扩展的位的；