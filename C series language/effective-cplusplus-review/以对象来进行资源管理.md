# 以对象来管理资源

条款13: 以对象来管理资源
---

这个就是为了防止C/C++的指针， 简直防狼一样；条款中使用STL中的auto_ptr shared_ptr;这里就有个典型例子就是锁的事情，利用析构和构造函数来确保锁资源的unlock；

- RAII原则
- 对于资源管理的对象，慎用copy行为；

**注意！**
auto_ptr 和 shared_ptr会使用delete 来释放资源而不会使用 delete [];所以用它们来管理数组是个绝对的错误选择

条款14: 同13最后一条建议
---

copy行为的几种处理机制：
- 禁止复制
- 使用引用计数
- 复制Raw Resource
- 转移Raw Resource

条款15: 在资源管理类中提供对原始资源的访问
---

典型的例子：stl中 unique_ptr、shared_ptr、auto_ptr 的 get, 但也可以使用隐式转换；


条款16: 成对的使用new 和 delete时要采用相同的形式
---

这没什么好说的， 必须要这样做；书中提到的typedef的形式值得注意⚠️；大型代码中特别要注意这种事情的发生； 一定的时候使用std::vector,等形式来管理对象；


条款17： 用独立的语句将new出的对象放入智能指针
---

这一条我一开始没能看明白， 后来看完才一拍脑袋，靠！又是异常，说实话，平常异常处理在垒代码的时候大家一般是不会在意的， 除了在面试的时候，😏；



