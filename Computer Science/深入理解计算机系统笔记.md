# 深入理解计算机系统第二版读书笔记

阅读这本书应该算是出于内心的一种担忧；虽然在日常coding中自我感觉良好， 加上自己从单片机系统到嵌入式系统到纯软件开发都有做过，自认为对一些基本的原则和设计方法有所了解，但有时候也过于自负，计算机系统的基本原理自己实际上还是缺乏系统的了解和认识， 所以也是出于这样的焦虑， 认为自己有必要重新踏实的来完成自己的这个小小的“遗憾”；毕竟自己是非科班出生的野路子程序员；也没有高大上的学历和能拿到当今这个浮躁的“互联网“世界的炫耀的工作岗位经历， 所有的这一切，权当自勉；



[大小端判断](/For Better Life/大小端判断.md)

## 第八章 异常控制流

计算机中的异常处理机制：处理器设计人员（如被零除、缺页，存储器访问违例等）以及操作系统开发人员（如系统调用以及来自外部的IO设备信号等）为每种类型的异常分配了一个唯一的非负整数异常号。在系统启动时，操作系统分配和初始化一张成为异常表的跳转表，该表使用异常号k作为索引，以每种类型的异常处理程序地址作为值。当处理器检测到一个事件（比如CPU根据管脚状态确定事件类型）发生时，确定异常号k，然后通过异常表目k转到相应的处理程序。异常表的地址通常保存在“异常表基址寄存器”中。

异常处理过程类似于过程调用：都会保存当前寄存器状态，和返回地址。但是，

- （1）异常处理的返回地址要么是当前执行指令，要么是当前执行指令的下一条指令。

- （2）异常发生时，如果此时内核代表用户程序执行(比如说系统调用)，这些状态将会被压入到内核栈，而不是压入到用户栈（过程调用压入方式）。
- （3）此外，对于异常处理程序通常运行在内核模式，此时对于所有的系统资源具有访问权限。

### 异常的类别

- （1）中断：中断是异步发生的，来自处理器外部IO设备的信号（区别于同步异常：执行一条指令的结果），它不是由任何一条专门的指令造成的。例如网络适配器、磁盘控制器通过向处理器芯片上的一个管脚发信号，并将异常号放在系统总线上，来触发中断，这个异常号标识了引起中断的设备。中断处理程序总是返回到当前指令的下一条指令。

- （2）陷阱：陷阱是同步异常，是执行一条指令的结果。陷阱最重要的用途是在用户程序和内核之间提供**系统调用接口**。陷阱总返回到当前指令的下一条指令。

- （3）故障：故障由错误引起，它可能被故常处理程序修正，如果修正成功，将返回到当前正在执行的指令，重新执行。否则处理程序返回到内核的abort历程，将终止故障程序。故障的一个典型是**缺页异常**。

- （4）终止：由不可恢复的知名错误造成的结果，处理程序将返回到内核中的abort例程，终止应用程序。

### 进程的上下文切换（context switch）

内核为每个进程维护了一个上下文。上下文就是内核重新启动一个被抢占进程所需要的状态集：通用寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈和各种内核数据结构（比如也表，进程表，文件表等）。内核通过调度器来抢占一个执行的进程：

（1）保护当前进程的上下文

（2）恢复某个先前被抢占进程所保存的上下文

（3）将控制传递给新回复的进程。

以下情况会发生上下文切换：

（1）当内核代表用户执行系统调用时。例如，系统调用因等待某个事件而发生阻塞，那么内核可以让当前进程休眠，切换到另一个进程，比如read请求磁盘访问。

（2）用户程序调用sleep系统调用，显式的让调用进程休眠。

（3）中断可能引发上下文切换。比如所有的系统都有某种产生周期性定时器中断的机制，典型的位1毫秒或10毫秒。每次发生定时器中断时，内核判断当前进程是否已经运行了足够长的时间，并切换到另一个进程。

### Unix信号

一个信号就是一条消息，它通知进程一个某种类型的时间已经在系统中发生。每种信号都对应某个类型的系统时间。

（1）底层的硬件异常是由内核异常处理程序处理的，对用户进程通常不可见，而信号提供了向用户进程通知这些异常发生的机制。比如：一个进程试图除以0，内核就会发送SIGFPE信号。

（2）其他的信号对应于内核或者其他用户中较高层次的软件事件。比如SIGINT、SIGKILL等。



## 第九章 虚拟存储器



![img](/Users/xiao/huan/do-it-like-an-engineer/Computer Science/assets/vm_mmu.png)



- 进程VM地址空间

- 内核VM地址空间
- 内核VM地址空间通过分割成虚拟页VP(virtual page)管理
- VP(virutal page)与对应的PP(physical page)对应, PP称之为页帧
- PTE: VP到PP的影响通过页表来管理与映射.页表条目(page table entry PTE)管理,同时PTE通过许可位和权限控制位来控制地址翻译的读写权限.
- VP的三种状态: 未分配、缓存、分配未缓存

过程描述: 

malloc时进程VM关联上内核VM, 访问VM时发生缺页异常(page fault), 通过PTE查找并进行换页, 从而在PTE中建立VP和PP的映射.返回中断恢复进程运行.Linux有多级页表地址管理结构. **局部性原理**: 页表不明中的性能处罚很大. 过度的页面调度(paging)会拖慢整个系统的速度.

- 简化了存储器的访问、
- 使得程序的link、loader变得统一

| VP命中时访问过程                                             | VP未命中时访问过程                                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![img](/Users/xiao/huan/do-it-like-an-engineer/Computer Science/assets/page_hit.jpg) | ![img](/Users/xiao/huan/do-it-like-an-engineer/Computer Science/assets/strip.png) |



### 页表的作用

通过上面的过程分析, 页面在MMU管理过程中至少可以有下列一些好处

- PTE 使得访问虚拟内存VM时, 对实际的物理地址的查找和访问变得统一化
- 也使的实际的物理内存可以使不连续的
- 这种方式也个想共享动态库共用一份提供了实现方式.

- PTE(page table entry) 通过定义的访问权限控制bitmask, 可以让访问更加安全.
- PTE页表项和物理地址是多对一的关系，即多个页表项可以对应一个物理页面，因而支持共享内存的实现（几个进程同时共享物理内存）。

1、写在指令中的地址统统都是虚拟地址，而不是实际的物理地址！
2、在X86这种同时进行段页式管理的硬件上，虚拟地址分成两级。指令中的那个值被称为“逻辑地址”，送给MMU中的“分段单元”，转换成线性地址。
3、线性地址再通过“分页单元”，转换成物理地址。
4、这个转换关系是需要预先配置好的，“分段单元”和“分页单元”都要有自己的硬件配置。
5、对“分页单元”来说，页表就是硬件配置，这个是绕不过去的。



先说明一下基本知识:首先，Linux的每个进程都有单独的页表，其中内核线程使用的是内核的页表。我们先不讨论内核线程这种情况，对于普通的进程来说，都有一个叫做mm_struct的结构体，它的成员pgd会指向内存中这个进程对应的页表。这个页表中的每一项（当然并不是所有页表项都是有效的）会描述整个虚拟内存空间。Linux userspace只能访问低于0xC0000000也就是PAGE_OFFSET的内存，高于它的内存属于内核空间地址。2. 对于普通进程来说，内核页表只是进程页表的一部分，它不是单独的一个东西。我们知道，Linux内核是为了服务于用户态的。正在运行的程序陷入内核态基本手段包括中断，系统调用。当CPU进入内核态之后，CPU访问内存地址还是要通过虚拟地址来访问的。此时访问虚拟地址就是通过被打断的进程的页表项才找到对应物理地址的。3. 内核页表其实在刚开机的时候就已经初始化好了，它存放的地址是swapper_pg_dir，也就是0XC0004000.这个地址里的每一项会描述1M的内存，0xc0007000到0xc0008000这段描述内核态的地址。每个用户态进程创建的时候，内核都会将这个页表复制到进程的页表中。而对于内核线程来说，由于一直工作在内核态，使用这个内核页表也就足够了。